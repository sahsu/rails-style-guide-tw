= Rails Style Guide
:idprefix:
:idseparator: -
:sectanchors:
:sectlinks:
:toc: preamble
:toclevels: 1
ifndef::backend-pdf[]
:toc-title: pass:[<h2>Table of Contents</h2>]
endif::[]
:source-highlighter: rouge
Table of Contents
目錄
]
endif::[] Endif: : []
:source-highlighter: rouge 校對: source-lightter 校對: rouge

== Introduction = = 引言

By https://github.com/bbatsov[Bozhidar Batsov] Https://github.com/bbatsov

[quote]
____
Role models are important. 榜樣很重要

-- Officer Alex J. Murphy / RoboCop
____

ifdef::env-github[]
TIP: You can find a beautiful version of this guide with much improved navigation at https://rails.rubystyle.guide. 小貼士: 你可以找到一個漂亮的版本， https://rails.rubystyle.guide 的導航有了很大的改進
endif::[]

The goal of this guide is to present a set of best practices and style prescriptions for Ruby on Rails development. 本指南的目標是為 Ruby on Rails 開發提供一組最佳實踐和樣式規範
It's a complementary guide to the already existing community-driven https://github.com/rubocop/ruby-style-guide[Ruby coding style guide]. 它是對已經存在的社區驅動 https://github.com/rubocop/Ruby-style-guide (Ruby 編碼風格指南)的補充

This Rails style guide recommends best practices so that real-world Rails programmers can write code that can be maintained by other real-world Rails programmers. 這個 Rails 風格指南推薦最佳實踐，這樣真實世界的 Rails 程式設計師就可以編寫可以由其他真實世界的 Rails 程式設計師維護的程式碼
A style guide that reflects real-world usage gets used, and a style guide that holds to an ideal that has been rejected by the people it is supposed to help risks not getting used at all - no matter how good it is. 一個反映現實世界使用情況的風格指南會被使用，而一個堅持理想的風格指南，如果它被認為能夠幫助人們的話，就有可能根本不會被使用——不管它有多好

The guide is separated into several sections of related rules. 該指南分為相關規則的幾個部分
I've tried to add the rationale behind the rules (if it's omitted I've assumed it's pretty obvious). 我已經嘗試新增規則背後的理由(如果省略了，我假設它是相當明顯的)

I didn't come up with all the rules out of nowhere - they are mostly based on my extensive career as a professional software engineer, feedback and suggestions from members of the Rails community and various highly regarded Rails programming resources. 我並沒有憑空想出所有的規則——它們大多基於我作為一個專業軟體工程師的廣泛職業生涯，來自 Rails 社區成員的反饋和建議，以及各種備受推崇的 Rails 程式設計資源

NOTE: Some of the advice here is applicable only to recent versions of Rails. 注意: 這裡的一些建議僅適用於 Rails 的最新版本

You can generate a PDF copy of this guide using https://asciidoctor.org/docs/asciidoctor-pdf/[AsciiDoctor PDF], and an HTML copy https://asciidoctor.org/docs/convert-documents/#converting-a-document-to-html[with] https://asciidoctor.org/#installation[AsciiDoctor] using the following commands: 你可以使用 https://AsciiDoctor.org/docs/AsciiDoctor-PDF/[ AsciiDoctor PDF ]生成本指南的 PDF 檔案，使用以下命令生成帶有 https://AsciiDoctor.org/docs/convert-documents/#converting-a-document-to-HTML [ AsciiDoctor ]的 HTML 檔案 https://AsciiDoctor.org/#installation :

[source,shell]
----
# Generates README.pdf
asciidoctor-pdf -a allow-uri-read README.adoc Asciidoctor-pdf-a allow-uri-read README.adoc

# Generates README.html
asciidoctor README.adoc
----

[TIP] [提示]
====
Install the `rouge` gem to get nice syntax highlighting in the generated document. 安裝’rouge’gem 可以在生成的檔案中獲得漂亮的語法突顯

[source,shell] [源，殼]
----
gem install rouge 寶石安裝胭脂
----
====

Translations of the guide are available in the following languages: 該指南的譯文如下:

* https://github.com/satour/rails-style-guide/blob/master/README-jaJA.md[Japanese]
* https://github.com/arbox/rails-style-guide/blob/master/README-ruRU.md[Russian]
* https://github.com/sahsu/rails-style-guide-tw/blob/master/README-zh-tw.adoc[Taiwan]

TIP: https://github.com/rubocop/rubocop[RuboCop], a static code analyzer (linter) and formatter, has a https://github.com/rubocop/rubocop-rails[`rubocop-rails`] extension, based on this style guide. 提示: https://github.com/RuboCop/RuboCop [ ruboCop ] ，一個靜態程式碼分析器(linter)和格式化程序，有一個基於這個樣式指南的 https://github.com/RuboCop/RuboCop-rails 擴展[‘ rubopolice-ails’]

== Configuration = = 組態

=== Config Initializers [[config-initializers]] = = = 組態初始化器[[組態初始化器]]

Put custom initialization code in `config/initializers`. 將自訂初始化程式碼放在‘ config/initializer’中
The code in initializers executes on application startup. 初始化器中的程式碼在應用程式啟動時執行

=== Gem Initializers [[gem-initializers]] = = = Gem 初始化器[[ Gem-initializer ]]

Keep initialization code for each gem in a separate file with the same name as the gem, for example `carrierwave.rb`, `active_admin.rb`, etc. 將每個 gem 的初始化程式碼保存在與 gem 同名的單獨檔案中，例如“ carrierwave. rb”、“ active _ admin”。等等

=== Dev/Test/Prod Configs [[dev-test-prod-configs]] = = = Dev/Test/Prod Configs [[ Dev-Test-Prod-Configs ]]

Adjust accordingly the settings for development, test and production environment (in the corresponding files under `config/environments/`) 相應地調整開發、測試和生產環境的設定(在“ config/environment/”下的相應檔案中)

Mark additional assets for precompilation (if any): 為預編譯標記額外的資產(如果有的話) :

[source,ruby] [來源，紅寶石]
----
# config/environments/production.rb # config/environment/production.rb
# Precompile additional assets (application.js, application.css, # 預編譯附加資產(application.js，application.css,
#and all non-JS/CSS are already added) # 和所有非 JS/CSS 已經新增)
config.assets.precompile += %w( rails_admin/rails_admin.css rails_admin/rails_admin.js ) Preedit + =% w (ails _ admin/ails _ admin. css ails _ admin/ails _ admin. js)
----

=== App Config [[app-config]] = = = App Config [[ App-Config ]]

Keep configuration that's applicable to all environments in the `config/application.rb` file. 在‘ config/application.rb’檔案中保留適用於所有環境的組態

=== Load Rails Config Defaults [[config-defaults]] = = = Load Rails Config Default [[ Config-default ]]

When upgrading to a newer Rails version, your application's configuration setting will remain on the previous version. To take advantage of the latest recommended Rails practices, the `config.load_defaults` setting should match your Rails version. 升級到較新的 Rails 版本時，應用程式的組態設定將保留在以前的版本上。為了利用最新推薦的 Rails 實踐，‘ config.load _ default’設定應該與您的 Rails 版本相匹配

[source,ruby] [來源，紅寶石]
----
# good # 好
config.load_defaults 6.1 Load _ default 6.1
----

=== Staging Like Prod [[staging-like-prod]] = = = 像普羅德一樣分階段[[像普羅德一樣分階段]]

Avoid creating additional environment configurations than the defaults of `development`, `test` and `production`. 避免建立比“開發”、“測試”和“生產”預設值更多的環境組態
If you need a production-like environment such as staging, use environment variables for configuration options. 如果需要類似於生產的環境(比如階段) ，請將環境變數用於組態選項

=== YAML Config [[yaml-config]] = = YAML Config [[ YAML-Config ]

Keep any additional configuration in YAML files under the `config/` directory. 在 YAML 檔案中的‘ config/’目錄下保存任何其他組態

Since Rails 4.2 YAML configuration files can be easily loaded with the new `config_for` method: 由於 Rails 4.2 YAML 組態檔案可以很容易地用新的‘ config _ for’方法載入:

[source,ruby] [來源，紅寶石]
----
Rails::Application.config_for(:yaml_file) Rails: : Application.config _ for (: yaml _ file)
----

== Routing = = 路由

=== Member Collection Routes [[member-collection-routes]] = = = 成員收集路由[[成員-收集-路由]]

When you need to add more actions to a RESTful resource (do you really need them at all?) use `member` and `collection` routes. 當您需要向 RESTful 資源新增更多操作時(您真的需要它們嗎?)使用“成員”和“收集”路線

[source,ruby] [來源，紅寶石]
----
# bad
get 'subscriptions/:id/unsubscribe' 獲取“訂閱/: id/取消訂閱”
resources :subscriptions 資源: 訂閱

# good # 好
resources :subscriptions do 資源: 訂閱服務
get 'unsubscribe', on: :member 取消訂閱
end 結束

# bad
get 'photos/search' 獲取’照片/搜尋’
resources :photos 資源: 照片

# good # 好
resources :photos do 資源: 照片
get 'search', on: :collection Get‘ search’，on: : Collection
end 結束
----

=== Many Member Collection Routes [[many-member-collection-routes]] = = = 許多成員收集路由[[ Many-Member-Collect- 路由]]

If you need to define multiple `member/collection` routes use the alternative block syntax. 如果需要定義多個“成員/集合”路由，可以使用可選的塊語法

[source,ruby] [來源，紅寶石]
----
resources :subscriptions do 資源: 訂閱服務
member do 成員做
get 'unsubscribe' 取消訂閱
# more routes 更多的路線
end 結束
end 結束

resources :photos do 資源: 照片
collection do 收集
get 'search' 得到’搜尋’
# more routes 更多的路線
end 結束
end 結束
----

=== Nested Routes [[nested-routes]] = = = 巢狀路線[[巢狀路線]]

Use nested routes to express better the relationship between Active Record models. 使用巢狀路由來更好地表達 ActiveRecord 模型之間的關係

[source,ruby] [來源，紅寶石]
----
class Post < ApplicationRecord 班級職位 < 申請紀錄
has_many :comments 有許多: 評論
end 結束

class Comment < ApplicationRecord 類別評論 < 申請紀錄
belongs_to :post 應該屬於: post
end 結束

# routes.rb 路線 RB
resources :posts do 資源: 員額
resources :comments 資源: 評論
end 結束
----

=== Shallow Routes [[shallow-routes]] = = 淺水路線[[淺水路線]]

If you need to nest routes more than 1 level deep then use the `shallow: true` option. 如果您需要巢狀路由深度超過1級，那麼使用“膚淺: 真實”選項
This will save user from long URLs `posts/1/comments/5/versions/7/edit` and you from long URL helpers `edit_post_comment_version`. 這將節省使用者從長 URL 的文章/1/註釋/5/版本/7/編輯’和您從長 URL 幫助’編輯 _ post _ 註釋 _ 版本’

[source,ruby] [來源，紅寶石]
----
resources :posts, shallow: true do 資源: 職位，淺: 真做
resources :comments do 資源: 意見
resources :versions 資源: 版本
end 結束
end 結束
----

=== Namespaced Routes [[namespaced-routes]] = = = 命名空間路由[[命名空間路由]]

Use namespaced routes to group related actions. 使用命名空間路由對相關操作進行分組

[source,ruby] [來源，紅寶石]
----
namespace :admin do 命名空間: admin do
# Directs /admin/products/* to Admin::ProductsController # Directs/Admin/products/* to Admin: : ProductsController
# (app/controllers/admin/products_controller.rb) # (app/controller/admin/products _ controller. rb)
resources :products 資源: 產品
end 結束
----

=== No Wild Routes [[no-wild-routes]] = = 沒有狂野之路[[沒有狂野之路]]

Never use the legacy wild controller route. 永遠不要使用遺留的通用控製器路由
This route will make all actions in every controller accessible via GET requests. 此路由將使每個控製器中的所有操作都可以通過 GET 請求訪問

[source,ruby] [來源，紅寶石]
----
# very bad # 非常糟糕
match ':controller(/:action(/:id(.:format)))' Match“ : controller (/: action (/: id (. : format)))”
----

=== No Match Routes [[no-match-routes]] = = 無匹配路由[[無匹配路由]]

Don't use `match` to define any routes unless there is need to map multiple request types among `[:get, :post, :patch, :put, :delete]` to a single action using `:via` option. 不要使用“ match”來定義任何路由，除非需要將“[ : get，: post，: patch，: put，: delete ]”之間的多個請求類型對應到使用“ : via”選項的單個操作

== Controllers = = 控制者

=== Skinny Controllers [[skinny-controllers]] = = = 瘦身控製器[[瘦身控製器]]

Keep the controllers skinny - they should only retrieve data for the view layer and shouldn't contain any business logic (all the business logic should naturally reside in the model). 保持控製器精簡——它們應該只檢索檢視層的資料，不應該包含任何業務邏輯(所有業務邏輯應該自然地駐留在模型中)

=== One Method [[one-method]] = = = One Method [[ One-Method ]]

Each controller action should (ideally) invoke only one method other than an initial find or new. 每個控製器操作(理想情況下)應該只呼叫初始 find 或 new 以外的一個方法

=== Shared Instance Variables [[shared-instance-variables]] = = = 共享實例變數[[共享實例變數]]

Minimize the number of instance variables passed between a controller and a view. 儘量減少控製器和檢視之間傳遞的實例變數的數量

=== Lexically Scoped Action Filter [[lexically-scoped-action-filter]] = = = 詞法範疇操作過濾器[[詞法範疇操作過濾器]]

Controller actions specified in the option of Action Filter should be in lexical scope. 操作篩選器選項中指定的控製器操作應該在詞法範圍內
The ActionFilter specified for an inherited action makes it difficult to understand the scope of its impact on that action. 為繼承操作指定的 ActionFilter 使得很難理解它對該操作的影響範圍

[source,ruby] [來源，紅寶石]
----
# bad
class UsersController < ApplicationController
before_action :require_login, only: :export Before _ action: need _ login，only: : export
end 結束

# good # 好
class UsersController < ApplicationController
before_action :require_login, only: :export Before _ action: need _ login，only: : export

def export 德福出口公司
end 結束
end 結束
----

== Controllers: Rendering [[rendering]] = = 控製器: 渲染[[渲染]]

=== Inline Rendering [[inline-rendering]] = = = 內聯渲染[[內聯渲染]]

Prefer using a template over inline rendering. 與內聯呈現相比，更喜歡使用範本

[source,ruby] [來源，紅寶石]
----
# very bad # 非常糟糕
class ProductsController < ApplicationController 類產品控製器 < 應用程式控製器
def index 清晰度指數
render inline: "<% products.each do |p| %> 內聯渲染:”<% products. each do | p |% >
<%= p.name %>

<% = p.name% >

<% end %>", type: :erb “ <% end% >”，類型: : erb
end 結束
end 結束

# good # 好
## app/views/products/index.html.erb # # app/views/products/index.html. erb
<%= render partial: 'product', collection: products %> <% = 呈現部分: “ product”，集合: products% >

## app/views/products/_product.html.erb # # app/views/products/_ product.html.erb
<%= product.name %>

<% = product.name% >


<%= product.price %>

<% = product.price% >



## app/controllers/products_controller.rb 應用程式/控製器/products _ controller. rb
class ProductsController < ApplicationController 類產品控製器 < 應用程式控製器
def index 清晰度指數
render :index 呈現: 索引
end 結束
end 結束
----

=== Plain Text Rendering [[plain-text-rendering]] = = = 純文字渲染[[純文字渲染]]

Prefer `render plain:` over `render text:`. 首選“渲染純文字:”優於“渲染文字:”

[source,ruby] [來源，紅寶石]
----
# bad - sets MIME type to `text/html` # bad-set MIME type to‘ text/html’
...
render text: 'Ruby!' 渲染文字: ‘ Ruby!’
...

# bad - requires explicit MIME type declaration Bad-需要顯式的 MIME 類型聲明
...
render text: 'Ruby!', content_type: 'text/plain' 呈現文字: ‘ Ruby!’，content _ type: ‘ text/print’
...

# good - short and precise # 短小精悍
...
render plain: 'Ruby!' 呈現原文: ‘ Ruby!’
...
----

=== HTTP Status Code Symbols [[http-status-code-symbols]] = = = HTTP狀態碼符號[[ http-status-code-marks ]]

Prefer https://gist.github.com/mlanett/a31c340b132ddefa9cca[corresponding symbols] to numeric HTTP status codes. 選擇 https://gist.github.com/mlanett/a31c340b132ddefa9cca [對應的符號]而不是數字 HTTP 狀態碼
They are meaningful and do not look like "magic" numbers for less known HTTP status codes. 它們是有意義的，並且不像不太為人所知的 HTTP 狀態碼的“神奇”數字

[source,ruby] [來源，紅寶石]
----
# bad
...
render status: 403 呈交狀況: 403
...

# good # 好
...
render status: :forbidden 禁止
...
----

== Models = = 模特兒

=== Model Classes [[model-classes]] = = = 模型類[[模型-類]]

Introduce non-Active Record model classes freely. 自由地引入非活動記錄模型類

=== Meaningful Model Names [[meaningful-model-names]] = = = 有意義的模型名[[有意義的模型名]]

Name the models with meaningful (but short) names without abbreviations. 使用有意義(但較短)的名稱命名模型，不使用縮寫

=== Non-ActiveRecord Models [[non-activerecord-models]] = = = 非 ActiveRecord 模型[[ non-activerrecord-model ]]

If you need objects that support ActiveRecord-like behavior (like validations) without the database functionality, use `ActiveModel::Model`. 如果您需要支援類 ActiveRecord 行為的對象(比如驗證)而不需要資料庫功能，請使用“ ActiveModel: : Model”

[source,ruby] [來源，紅寶石]
----
class Message 課堂資訊
include ActiveModel::Model 包括 ActiveModel: : Model

attr_accessor :name, :email, :content, :priority Attr _ accessor: name，: email，: content，: first

validates :name, presence: true 確認: 名稱，存在: 真實
validates :email, format: { with: /\A[-a-z0-9_+\.]+\@([-a-z0-9]+\.)+[a-z0-9]{2,4}\z/i } 格式: { with:/A [-a-z0-9 _ + . ] +@([-a-z0-9] + .) + [ a-z0-9]{2,4} z/i }
validates :content, length: { maximum: 500 } Validates: content，length: { max: 500}驗證: 內容，長度: {最大: 500}
end 結束
----

Starting with Rails 6.1, you can also extend the attributes API from ActiveRecord using `ActiveModel::Attributes`. 從 Rails 6.1開始，您還可以使用“ ActiveModel: : Attritribute”擴展 ActiveRecord 的屬性 API

[source,ruby] [來源，紅寶石]
----
class Message 課堂資訊
include ActiveModel::Model 包括 ActiveModel: : Model
include ActiveModel::Attributes 包括 ActiveModel: : 屬性

attribute :name, :string 屬性: name，: string
attribute :email, :string 屬性: email，: string
attribute :content, :string 屬性: content，: string
attribute :priority, :integer 屬性:

validates :name, presence: true 確認: 名稱，存在: 真實
validates :email, format: { with: /\A[-a-z0-9_+\.]+\@([-a-z0-9]+\.)+[a-z0-9]{2,4}\z/i } 格式: { with:/A [-a-z0-9 _ + . ] +@([-a-z0-9] + .) + [ a-z0-9]{2,4} z/i }
validates :content, length: { maximum: 500 } Validates: content，length: { max: 500}驗證: 內容，長度: {最大: 500}
end 結束
----

=== Model Business Logic [[model-business-logic]] = = = 模型業務邏輯[[模型-業務-邏輯]]

Unless they have some meaning in the business domain, don't put methods in your model that just format your data (like code generating HTML). 除非它們在業務領域中具有某種意義，否則不要在模型中放置只是格式化資料的方法(如程式碼生成 HTML)
These methods are most likely going to be called from the view layer only, so their place is in helpers. 這些方法很可能只從檢視層呼叫，因此它們的位置在幫助程序中
Keep your models for business logic and data-persistence only. 只保留業務邏輯和資料持久性模型

== Models: Active Record [[activerecord]] = = 模型: 活動記錄[[ activerrecord ]]

=== Keep Active Record Defaults [[keep-ar-defaults]] = = = 保持活動記錄預設值[[ Keep-ar-default ]]

Avoid altering Active Record defaults (table names, primary key, etc) unless you have a very good reason (like a database that's not under your control). 避免更改 Active Record 預設值(表名、主鍵等) ，除非你有一個很好的理由(比如資料庫不在你的控制之下)

[source,ruby] [來源，紅寶石]
----
# bad - don't do this if you can modify the schema # bad-如果可以修改模式，請不要這樣做
class Transaction < ApplicationRecord 類別交易 < 申請紀錄
self.table_name = 'order' Table _ name = ‘ order’
...
end 結束
----

=== Always append to `ignored_columns` [[append-ignored-columns]] = = = 總是追加到“忽略 _ 列”[[追加-忽略-列]]

Avoid setting `ignored_columns`. It may overwrite previous assignments and that is almost always a mistake. Prefer appending to the list instead. 避免設定“忽略 _ 列”。它可能會覆蓋以前的任務，這幾乎總是一個錯誤。更喜歡附加到列表中

[source,ruby] [來源，紅寶石]
----
class Transaction < ApplicationRecord 類別交易 < 申請紀錄
# bad - it may overwrite previous assignments 壞-它可能覆蓋以前的任務
self.ignored_columns = %i[legacy] 無視 _ column =% i [遺產]

# good - the value is appended to the list # good-值被附加到列表中
self.ignored_columns += %i[legacy] 無視 _ column + =% i [遺產]
...
end 結束
----

=== Enums [[enums]] = = = Enums [[ Enums ]]

Prefer using the hash syntax for `enum`. Array makes the database values implicit 首選使用‘ enum’的雜湊語法。陣列使資料庫值隱式
& any insertion/removal/rearrangement of values in the middle will most probably & 任何在中間插入/移除/重新排列的值很可能
lead to broken code. 導致程式碼被破解

[source,ruby] [來源，紅寶石]
----
class Transaction < ApplicationRecord 類別交易 < 申請紀錄
# bad - implicit values - ordering matters 壞-隱式值-排序很重要
enum type: %i[credit debit] 列舉類型:% i [信貸借方]

# good - explicit values - ordering does not matter 好-顯式值-排序不重要
enum type: { 列舉類型: {
credit: 0, 來源: 0,
debit: 1 借方: 1
}
end 結束
----

=== Macro Style Methods [[macro-style-methods]] = = = 宏樣式方法[[宏樣式-方法]]

Group macro-style methods (`has_many`, `validates`, etc) in the beginning of the class definition. 在類定義的開頭對宏樣式方法(‘ has _ many’、‘ validates’等)進行分組

[source,ruby] [來源，紅寶石]
----
class User < ApplicationRecord
# keep the default scope first (if any) # 首先保留默認範圍(如果有的話)
default_scope { where(active: true) } Default _ scope { where (active: true)}

# constants come up next # 接下來是常數
COLORS = %w(red green blue) 顏色 =% w (紅綠藍)

# afterwards we put attr related macros # 之後我們把 attr 相關的宏
attr_accessor :formatted_date_of_birth Attr _ accessor: format _ date _ of _ born

attr_accessible :login, :first_name, :last_name, :email, :password Attr _ access: login，: first _ name，: last _ name，: email，: password

# Rails 4+ enums after attr macros # Rails 4 + 在 attr 宏之後的列舉
enum role: { user: 0, moderator: 1, admin: 2 } 列舉角色: { user: 0，版主: 1，管理員: 2}

# followed by association macros # 後面跟著關聯宏
belongs_to :country 屬於: country

has_many :authentications, dependent: :destroy Has _ many: 認證，依賴於: : delete

# and validation macros # 和驗證宏
validates :email, presence: true 驗證: 電子郵件，存在: 真實
validates :username, presence: true 確認: 使用者名稱，存在: 真實
validates :username, uniqueness: { case_sensitive: false } Validates: username，惟一性: { case _ infections: false }
validates :username, format: { with: /\A[A-Za-z][A-Za-z0-9._-]{2,19}\z/ } Validates: username，format: { with:/A [ A-Za-z ][ A-Za-z0-9. _-]{2,19} z/}驗證: 使用者名稱，格式: { with:/A [ A-Za-z ][ A-Za-z0-9. _-]{2,19} z/}
validates :password, format: { with: /\A\S{8,128}\z/, allow_nil: true } Validates: password，format: { with:/A. S {8,128} z/，allow _ nil: true }驗證: 密碼，格式: { with:/A. S {8,128} z/，allow _ nil: true }

# next we have callbacks # next we have callback
before_save :cook 烹飪
before_save :update_username_lower Before _ save: update _ username _ lower

# other macros (like devise's) should be placed after the callbacks # 其他宏(如 design’s)應該放在回呼之後

...
end 結束
----

=== `has_many :through` [[has-many-through]] = = ‘ has _ many: through’[[ has-many-through ]]

Prefer `has_many :through` to `has_and_belongs_to_many`. 首選“ has _ many: through”到“ has _ and _ properties _ to _ many”
Using `has_many :through` allows additional attributes and validations on the join model. 使用“ has _ many: through”允許在連接模型上新增額外的屬性和驗證

[source,ruby] [來源，紅寶石]
----
# not so good - using has_and_belongs_to_many # not so good-using has _ and _ properties _ to _ many
class User < ApplicationRecord
has_and_belongs_to_many :groups Has _ and _ properties _ to _ many: group
end 結束

class Group < ApplicationRecord 類別 < 申請紀錄
has_and_belongs_to_many :users Has _ and _ properties _ to _ many: users
end 結束

# preferred way - using has_many :through 首選方法-using has _ many: through
class User < ApplicationRecord
has_many :memberships 有許多: 會員資格
has_many :groups, through: :memberships Has _ many: group，through: : member
end 結束

class Membership < ApplicationRecord 類別成員 < 申請紀錄
belongs_to :user Properties _ to: user 屬於: 使用者
belongs_to :group 應屬於: group
end 結束

class Group < ApplicationRecord 類別 < 申請紀錄
has_many :memberships 有許多: 會員資格
has_many :users, through: :memberships Has _ many: users，through: : member
end 結束
----

=== Read Attribute [[read-attribute]] = = = Read Attribute [[ Read-tribute ]]

Prefer `self[:attribute]` over `read_attribute(:attribute)`. “ self [ : Attribute ]‘ over‘ read _ tribute (: Attribute)’”更喜歡“ self [ : Attribute ]‘

[source,ruby] [來源，紅寶石]
----
# bad
def amount 定額
read_attribute(:amount) * 100 Read _ tribute (: amount) * 100
end 結束

# good # 好
def amount 定額
self[:amount] * 100 自己[ : 金額] * 100
end 結束
----

=== Write Attribute [[write-attribute]] = = = Write Attribute [[ Write-tribute ]]

Prefer `self[:attribute] = value` over `write_attribute(:attribute, value)`. “ self [ : tribute ] = value‘ over‘ write _ tribute (: Attribute，value)’”更喜歡“ self [ : tribute ] = value‘而不是‘ write _ tribute (: Attribute，value)’”

[source,ruby] [來源，紅寶石]
----
# bad
def amount 定額
write_attribute(:amount, 100) Write _ tribute (: amount，100)
end 結束

# good # 好
def amount 定額
self[:amount] = 100 自己[ : 金額] = 100
end 結束
----

=== New-style Validations [[new-style-validations]] = = = New-style Validations [[ New-style-Validations ]]

Always use the http://thelucid.com/2010/01/08/sexy-validation-in-edge-rails-rails-3/["new-style" validations]. 始終使用 http://thelucid.com/2010/01/08/sexy-validation-in-edge-rails-rails-3/[“新式”驗證]

[source,ruby] [來源，紅寶石]
----
# bad
validates_presence_of :email 電子郵件
validates_length_of :email, maximum: 100 Validates _ length _ of: email，最大值: 100

# good # 好
validates :email, presence: true, length: { maximum: 100 } 確認: email，盛況: true，長度: { max: 100}
----

=== Custom Validation Methods = = 自訂驗證方法

When naming custom validation methods, adhere to the simple rules: 在命名自訂驗證方法時，請遵循以下簡單規則:

- `validate :method_name` reads like a natural statement ‘ valid: method _ name’讀起來像一個自然的語句
- the method name explains what it checks 方法名解釋了它檢查的內容
- the method is recognizable as a validation method by its name, not a predicate method - 該方法可以通過其名稱而不是謂詞方法識別為驗證方法

[source,ruby] [來源，紅寶石]
----
# good # 好
validate :expiration_date_cannot_be_in_the_past 失效日期不能成為過去
validate :discount_cannot_be_greater_than_total_value 減價 _ 不能 _ 大於 _ 總價值
validate :ensure_same_topic_is_chosen Sure _ same _ subject _ is _ select

# also good - explicit prefix # 也是好的-明確的前綴
validate :validate_birthday_in_past 過去的生日
validate :validate_sufficient_quantity 足夠的數量
validate :must_have_owner_with_no_other_items Must _ have _ owner _ with _ no _ other _ item 驗證: must _ have _ owner _ with _ no _ other _ item
validate :must_have_shipping_units Must _ have _ Shipping _ unit 驗證: must _ have _ Shipping _ unit

# bad
validate :birthday_in_past 過去的生日
validate :owner_has_no_other_items Owner _ has _ no _ other _ item
----

=== Single-attribute Validations [[single-attribute-validations]] = = = 單屬性驗證[[ single-tribute-Validations ]]

To make validations easy to read, don't list multiple attributes per validation. 為了使驗證更容易閱讀，不要在每個驗證中列出多個屬性

[source,ruby] [來源，紅寶石]
----
# bad
validates :email, :password, presence: true 驗證: 電子郵件，: 密碼，存在: 真實
validates :email, length: { maximum: 100 } 校驗: email，長度: { max: 100}

# good # 好
validates :email, presence: true, length: { maximum: 100 } 確認: email，盛況: true，長度: { max: 100}
validates :password, presence: true 驗證: password，being: true
----

=== Custom Validator File [[custom-validator-file]] = = = 自訂驗證程序檔案[[自訂驗證程序檔案]]

When a custom validation is used more than once or the validation is some regular expression mapping, create a custom validator file. 當自訂驗證被多次使用或驗證是某種正規表示式對應時，請建立自訂驗證程序檔案

[source,ruby] [來源，紅寶石]
----
# bad
class Person 類別人士
validates :email, format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i } 校驗: email，格式: { with:/A ([ ^@s ] +)@(? : [-a-z0-9] + .) + [ a-z ]{2，}) z/i }
end 結束

# good # 好
class EmailValidator < ActiveModel::EachValidator Class EmailValidator < ActiveModel: : EachValidator
def validate_each(record, attribute, value) Def valid_ each (記錄、屬性、值)
record.errors[attribute] << (options[:message] || 'is not a valid email') unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i 除非 value = ~/A ([ ^@s ] +)@(? : [-a-z0-9] + .) + [ a-z ]{2，}) z/i
end 結束
end 結束

class Person 類別人士
validates :email, email: true 驗證: 電子郵件，電子郵件: 真實
end 結束
----

=== App Validators [[app-validators]] = = = App Validators [[ App-Validators ]]

Keep custom validators under `app/validators`. 將自訂驗證器保留在“ app/validators”下

=== Custom Validators Gem [[custom-validators-gem]] = = = Custom Validators Gem [[ Custom- Validators-Gem ]]

Consider extracting custom validators to a shared gem if you're maintaining several related apps or the validators are generic enough. 如果要維護幾個相關的應用程式，或者驗證程序足夠通用，可以考慮將自訂驗證程序提取到一個共享 gem 中

=== Named Scopes [[named-scopes]] = = = 命名範疇[[命名範疇]]

Use named scopes freely. 可以自由地使用命名範疇

[source,ruby] [來源，紅寶石]
----
class User < ApplicationRecord
scope :active, -> { where(active: true) } 範疇: active,-> { where (active: true)}
scope :inactive, -> { where(active: false) } 範疇: inactive,-> { where (active: false)}

scope :with_orders, -> { joins(:orders).select('distinct(users.id)') } 範疇: with _ orders,-> { join (: orders) . select (‘ different (users.id)’)}
end 結束
----

=== Named Scope Class [[named-scope-class]] = = = 命名範圍類[[命名範圍類]]

When a named scope defined with a lambda and parameters becomes too complicated, it is preferable to make a class method instead which serves the same purpose of the named scope and returns an `ActiveRecord::Relation` object. 當使用 lambda 和參數定義的命名範圍變得過於複雜時，最好使用一個類方法，該類方法與命名範圍的用途相同，並返回一個“ ActiveRecord: : Relations”對象
Arguably you can define even simpler scopes like this. 可以說，您可以像這樣定義更簡單的範疇

[source,ruby] [來源，紅寶石]
----
class User < ApplicationRecord
def self.with_orders Def self. with _ orders
joins(:orders).select('distinct(users.id)') Join (: order) . select (‘ different (users.id)’)
end 結束
end 結束
----

=== Callbacks Order [[callbacks-order]] = = = 回呼順序[[回呼順序]]

Order callback declarations in the order in which they will be executed. 按照回呼聲明的執行順序排序
For reference, see https://guides.rubyonrails.org/active_record_callbacks.html#available-callbacks[Available Callbacks]. 參考 https://guides.rubyonrails.org/active_record_callbacks.html#Available-Callbacks [可用回呼]

[source,ruby] [來源，紅寶石]
----
# bad
class Person 類別人士
after_commit :after_commit_callback After _ commit: after _ commit _ callback
before_validation :before_validation_callback Before _ valid_ callback
end 結束

# good # 好
class Person 類別人士
before_validation :before_validation_callback Before _ valid_ callback
after_commit :after_commit_callback After _ commit: after _ commit _ callback
end 結束
----

=== Beware Skip Model Validations [[beware-skip-model-validations]] = = = 小心跳過模型驗證[[小心跳過模型驗證]]

Beware of the behavior of the https://guides.rubyonrails.org/active_record_validations.html#skipping-validations[following] methods. 小心 https://guides.rubyonrails.org/active_record_validations.html#skipping-validations [以下]方法的行為
They do not run the model validations and could easily corrupt the model state. 它們不運行模型驗證，並且很容易破壞模形狀態

[source,ruby] [來源，紅寶石]
----
# bad
Article.first.decrement!(:view_count) (: view _ count)
DiscussionBoard.decrement_counter(:post_count, 5) 減量 _ 計數器(: post _ count，5)
Article.first.increment!(:view_count) (: view _ count)
DiscussionBoard.increment_counter(:post_count, 5) Ment _ counter (: post _ count，5)
person.toggle :active 啟動
product.touch 產品，觸摸
Billing.update_all("category = 'authorized', author = 'David'") Update _ all (“ type = ‘ authored’，author = ‘ David’”)
user.update_attribute(:website, 'example.com') Update _ tribute (: site，‘ example.com’)
user.update_columns(last_request_at: Time.current) Update _ column (last _ request _ at: Time.current)
Post.update_counters 5, comment_count: -1, action_count: 1 Update _ counter 5，comments _ count: -1，action _ count: 1

# good # 好
user.update_attributes(website: 'example.com') Update _ properties (網址: ‘ example.com’)
----

=== User-friendly URLs [[user-friendly-urls]] = = = 使用者友好的 URL [[使用者友好的 URLs ]]

Use user-friendly URLs. 使用使用者友好的 URL
Show some descriptive attribute of the model in the URL rather than its `id`. 在 URL 中顯示模型的一些描述性屬性，而不是模型的“ id”
There is more than one way to achieve this. 實現這一目標的方法不止一種

==== Override the `to_param` Method of the Model = = = = 覆蓋模型的‘ to _ param’方法

This method is used by Rails for constructing a URL to the object. Rails 使用此方法構造對象的 URL
The default implementation returns the `id` of the record as a String. 默認實現將記錄的“ id”作為 String 返回
It could be overridden to include another human-readable attribute. 可以重寫它以包含另一個人類可讀的屬性

[source,ruby] [來源，紅寶石]
----
class Person 類別人士
def to_param Def to _ param
"#{id} #{name}".parameterize “ # { id } # { name }”. 參數化
end 結束
end 結束
----

In order to convert this to a URL-friendly value, `parameterize` should be called on the string. 為了將其轉換為 URL 友好的值，應該對字串呼叫“參數化”
The `id` of the object needs to be at the beginning so that it can be found by the `find` method of Active Record. 對象的“ id”需要放在開頭，這樣才能通過 ActiveRecord 的“ find”方法找到它

==== `friendly_id` Gem = = = 友好的寶石 =

It allows creation of human-readable URLs by using some descriptive attribute of the model instead of its `id`. 它允許通過使用模型的一些描述性屬性而不是它的“ id”來建立人類可讀的 URL

[source,ruby] [來源，紅寶石]
----
class Person 類別人士
extend FriendlyId 延長 FriendlyId
friendly_id :name, use: :slugged Friend _ id: name，use: : sluged
end 結束
----

Check the https://github.com/norman/friendly_id[gem documentation] for more information about its usage. 查看 https://github.com/norman/friendly_id [ gem 檔案]瞭解更多關於其用法的資訊

=== `find_each` [[find-each]] = = = ‘ find _ each’[[ find-each ]]

Use `find_each` to iterate over a collection of AR objects. 使用‘ find _ each’對 AR 對象集合進行迭代
Looping through a collection of records from the database (using the `all` method, for example) is very inefficient since it will try to instantiate all the objects at once. 循環遍曆數據庫中的記錄集合(例如，使用‘ all’方法)效率非常低，因為它將嘗試一次實例化所有對象
In that case, batch processing methods allow you to work with the records in batches, thereby greatly reducing memory consumption. 在這種情況下，批處理方法允許您批處理記錄，從而大大減少了記憶體消耗

[source,ruby] [來源，紅寶石]
----
# bad
Person.all.each do |person| 每個人
person.do_awesome_stuff 做很棒的事情
end 結束

Person.where('age > 21').each do |person| 人。(年齡 > 21)。每做 | 人 |
person.party_all_night! 徹夜狂歡
end 結束

# good # 好
Person.find_each do |person| Find _ each do | person |
person.do_awesome_stuff 做很棒的事情
end 結束

Person.where('age > 21').find_each do |person| Person. where (‘ age > 21’) . find _ each do | person |
person.party_all_night! 徹夜狂歡
end 結束
----

=== `before_destroy` [[before_destroy]] = = = ‘ before _ delete’[[ before _ delete ]]

Since https://github.com/rails/rails/issues/3458[Rails creates callbacks for dependent associations], always call `before_destroy` callbacks that perform validation with `prepend: true`. 由於 https://github.com/Rails/Rails/issues/3458[ Rails 為依賴關聯建立回呼函數] ，所以總是呼叫‘ before _ delete’回呼函數，這些回呼函數使用‘ prepend: true’執行驗證

[source,ruby] [來源，紅寶石]
----
# bad (roles will be deleted automatically even if super_admin? is true) # bad (即使 super _ admin? 為 true，角色也會自動刪除)
has_many :roles, dependent: :destroy Has _ many: role， 相關的: : delete

before_destroy :ensure_deletable Before _ delete: sure _ deletable

def ensure_deletable Def sure _ deletable 可刪除
raise "Cannot delete super admin." if super_admin? 引發“無法刪除超級管理員。”如果超級管理員？
end 結束

# good # 好
has_many :roles, dependent: :destroy Has _ many: role， 相關的: : delete

before_destroy :ensure_deletable, prepend: true Before _ delete: sure _ deletable，prepend: true

def ensure_deletable Def sure _ deletable 可刪除
raise "Cannot delete super admin." if super_admin? 引發“無法刪除超級管理員。”如果超級管理員？
end 結束
----

=== `has_many`/`has_one` Dependent Option [[has_many-has_one-dependent-option]] = = = “ has _ many”/“ has _ one”相關選項[[ has _ many-has _ one-Depent- Option ]]

Define the `dependent` option to the `has_many` and `has_one` associations. 定義“ has _ many”和“ has _ one”關聯的“依賴”選項

[source,ruby] [來源，紅寶石]
----
# bad
class Post < ApplicationRecord 班級職位 < 申請紀錄
has_many :comments 有許多: 評論
end 結束

# good # 好
class Post < ApplicationRecord 班級職位 < 申請紀錄
has_many :comments, dependent: :destroy 具有 _ many: 註釋，依賴
end 結束
----

=== `save!` [[save-bang]] = = = ‘ save!’[ Save-bang ]

When persisting AR objects always use the exception raising bang! method or handle the method return value. 當持久化 AR 對象時，總是使用異常引發 bang! 方法或處理方法返回值
This applies to `create`, `save`, `update`, `destroy`, `first_or_create` and `find_or_create_by`. 這適用於“建立”、“保存”、“更新”、“銷毀”、“首先”或“建立”以及“尋找”或“建立”

[source,ruby] [來源，紅寶石]
----
# bad
user.create(name: 'Bruce') Create (名稱: ‘ Bruce’)

# bad
user.save 使用者，保存

# good # 好
user.create!(name: 'Bruce') Create! (名稱: ‘ Bruce’)
# or # 或者
bruce = user.create(name: 'Bruce') Bruce = user.create (名稱: ‘ Bruce’)
if bruce.persisted? 如果 Bruce 堅持的話？
...
else 別的
...
end 結束

# good # 好
user.save! 使用者，保存
# or # 或者
if user.save 如果使用者，保存
...
else 別的
...
end 結束
----

== Models: Active Record Queries [[activerecord-queries]] = = 模型: 活動記錄查詢[[ activerecord-query ]]

=== Avoid Interpolation [[avoid-interpolation]] = = = 避免插值[[避免-插值]]

Avoid string interpolation in queries, as it will make your code susceptible to SQL injection attacks. 避免在查詢中使用字串插入，因為它會使程式碼容易受到 SQL 隱碼攻擊

[source,ruby] [來源，紅寶石]
----
# bad - param will be interpolated unescaped # bad-param will be interpolated unescape
Client.where("orders_count = #{params[:orders]}") Where (“ order _ count = # { params [ : orders ]}”)

# good - param will be properly escaped # 好-帕拉姆將被妥善地逃脫
Client.where('orders_count = ?', params[:orders]) Where (‘ order _ count = ?’，params [ : orders ])
----

=== Named Placeholder [[named-placeholder]] = = = 命名預留位置[[命名-預留位置]]

Consider using named placeholders instead of positional placeholders when you have more than 1 placeholder in your query. 當查詢中有多個預留位置時，請考慮使用命名預留位置而不是位置預留位置

[source,ruby] [來源，紅寶石]
----
# okish # 好吧
Client.where( 客戶
'orders_count >= ? AND country_code = ?', “ order _ count > = ? AND country _ code = ?”,
params[:min_orders_count], params[:country_code] Params [ : min _ orders _ count ] ，params [ : country _ code ]
)

# good # 好
Client.where( 客戶
'orders_count >= :min_orders_count AND country_code = :country_code', “ order _ count > = : min _ orders _ count AND country _ code = : country _ code”
min_orders_count: params[:min_orders_count], country_code: params[:country_code] Min _ orders _ count: params [ : min _ orders _ count ] ，country _ code: params [ : country _ code ]
)
----

=== `find` [[find]] = = = ‘ find’[[ find ]]

Prefer `find` over `where.take!`, `find_by!`, and `find_by_id!` when you need to retrieve a single record by primary key id and raise `ActiveRecord::RecordNotFound` when the record is not found. 我喜歡在哪裡找，拿去吧！找到了！然後通過 id 找到！當您需要通過主鍵 id 檢索單個記錄時，如果找不到記錄，則引發“ ActiveRecord: : RecordNotfound”

[source,ruby] [來源，紅寶石]
----
# bad
User.where(id: id).take! 使用者. where (id: id) . take

# bad
User.find_by_id!(id) Find _ by _ id! (id)

# bad
User.find_by!(id: id) Find _ by! (id: id)

# good # 好
User.find(id) Find (id)
----

=== `find_by` [[find_by]] = = = ‘ find _ by’[[ find _ by ]]

Prefer `find_by` over `where.take` and `find_by_attribute` when you need to retrieve a single record by one or more attributes and return `nil` when the record is not found. 如果需要通過一個或多個屬性檢索單個記錄，請選擇“ find _ by”而不是“ where. take”和“ find _ by _ tribute”，如果沒有找到記錄，則返回“ nil”

[source,ruby] [來源，紅寶石]
----
# bad
User.where(email: email).take 使用者在哪裡(電子郵件: 電子郵件)
User.where(first_name: 'Bruce', last_name: 'Wayne').take Where (first _ name: ‘ Bruce’，last _ name: ‘ Wayne’) . take

# bad
User.find_by_email(email) Find _ by _ email (email)
User.find_by_first_name_and_last_name('Bruce', 'Wayne') Find _ by _ first _ name _ and _ last _ name (‘ Bruce’，‘ Wayne’)

# good # 好
User.find_by(email: email) Find _ by (email: email)
User.find_by(first_name: 'Bruce', last_name: 'Wayne') Find _ by (first _ name: ‘ Bruce’，last _ name: ‘ Wayne’)
----

=== Hash conditions [[where-not]] [[hash-conditions]] = = = 雜湊條件[[ where-not ]][[ Hash-treaty ]]

Prefer passing conditions to `where` and `where.not` as a hash over using fragments of SQL. 與使用 SQL 片段相比，更喜歡將條件傳遞到‘ where’和‘ where. not’作為雜湊

[source,ruby] [來源，紅寶石]
----
# bad
User.where("name = ?", name) Where (“ name = ?”，name)

# good # 好
User.where(name: name) Where (name: name)

# bad
User.where("id != ?", id) Where (“ id! = ?”，id)

# good # 好
User.where.not(id: id) Not (id: id)
----

=== Finding missing relationship records [[finding-missing-relationship-records]] = = = 尋找丟失的關係記錄[[尋找-丟失的關係記錄]]

If you're using Rails 6.1 or higher, use https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods/WhereChain.html#method-i-missing[where.missing] to find missing relationship records. 如果你使用 Rails 6.1或更高版本，使用 https://api.rubyonrails.org/classes/activerecord/querymethods/wherechain.html#method-i-missing 尋找丟失的關係記錄

[source,ruby] [來源，紅寶石]
----
# bad
Post.left_joins(:author).where(authors: { id: nil }) Left _ join (: author) . where (author: { id: nil })

# good # 好
Post.where.missing(:author) Post.where. miss (: author)
----

=== Order by `id` [[order-by-id]] = = = Order by‘ id’[[ Order-by-id ]]

Don't use the `id` column for ordering. 不要使用‘ id’列進行排序
The sequence of ids is not guaranteed to be in any particular order, despite often (incidentally) being chronological. Id 的順序不能保證是任何特定的順序，儘管經常(偶然地)是按時間順序排列的
Use a timestamp column to order chronologically. 使用時間戳列按時間順序排序
As a bonus the intent is clearer. 作為獎勵，意圖更加清晰

[source,ruby] [來源，紅寶石]
----
# bad
scope :chronological, -> { order(id: :asc) } 範疇: 時間順序,-> { order (id: : asc)}

# good # 好
scope :chronological, -> { order(created_at: :asc) } 範疇: 時間順序,-> { order (create _ at: : asc)}
----

=== `pluck` = = “勇氣”=

Use https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-pluck[pluck] to select a single value from multiple records. 使用 https://api.rubyonrails.org/classes/activerecord/calculations.html#method-i-pluck [ pluck ]從多個記錄中選擇一個值

[source,ruby] [來源，紅寶石]
----
# bad
User.all.map(&:name) Map (& : name)

# bad
User.all.map { |user| user[:name] } Map { | user | user [ : name ]}

# good # 好
User.pluck(:name) Pluck (: name)
----

=== `pick` = = 選擇

Use https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-pick[pick] to select a single value from a single record. 使用 https://api.rubyonrails.org/classes/activerecord/calculations.html#method-i-pick [ pick ]從單個記錄中選擇一個值

[source,ruby] [來源，紅寶石]
----
# bad
User.pluck(:name).first Pluck (: name) . first

# bad
User.first.name 使用者名稱

# good # 好
User.pick(:name) Pick (: name)
----

=== `ids` [[ids]] = = = ‘ ids’[[ ids ]]

Prefer `ids` over `pluck(:id)`. 喜歡‘ ids’勝過‘ pluck (: id)’

[source,ruby] [來源，紅寶石]
----
# bad
User.pluck(:id) User.pluck (: id)

# good # 好
User.ids 使用者名稱
----

=== Squished Heredocs [[squished-heredocs]] = = = 壓扁的異端[[壓扁的異端]]

When specifying an explicit query in a method such as `find_by_sql`, use heredocs with `squish`. 在諸如“ find _ by _ sql”之類的方法中指定顯式查詢時，請使用“ squish”的 herdocs
This allows you to legibly format the SQL with line breaks and indentations, while supporting syntax highlighting in many tools (including GitHub, Atom, and RubyMine). 這使得你可以清晰地用分行符號和縮排格式化 SQL，同時在許多工具(包括 GitHub、 Atom 和 RubyMine)中支援語法突顯

[source,ruby] [來源，紅寶石]
----
User.find_by_sql(<<-SQL.squish) Find _ by _ sql (< <-SQL.squish)
SELECT 選擇
users.id, accounts.plan 使用者 ID 帳戶 Plan
FROM 來自
users 使用者
INNER JOIN 內連接
accounts 帳目
ON 開始
accounts.user_id = users.id User _ id = users.id
# further complexities... 更複雜
SQL
----

https://api.rubyonrails.org/classes/String.html#method-i-squish[`String#squish`] removes the indentation and newline characters so that your server log shows a fluid string of SQL rather than something like this:

----
SELECT\n users.id, accounts.plan\n FROM\n users\n INNER JOIN\n accounts\n ON\n accounts.user_id = users.id 選擇 n users.id，Accounts.plan n FROM n users n INNER JOIN n account n ON n Accounts.user _ id = users.id
----

=== `size` over `count` or `length` [[size-over-count-or-length]] = = = ‘ size’over‘ count’or‘ length’[[ size-over-count-or-length ]]

When querying Active Record collections, prefer `size` (selects between count/length behavior based on whether collection is already loaded) or `length` (always loads the whole collection and counts the array elements) over `count` (always does a database query for the count). 在查詢 Active Record 集合時，優先選擇“ size”(根據集合是否已載入在 count/length 行為之間進行選擇)或“ length”(總是載入整個集合併計數陣列元素)而不是“ count”(總是對 count 進行資料庫查詢)

[source,ruby] [來源，紅寶石]
----
# bad
User.count 使用者數

# good # 好
User.all.size

# good - if you really need to load all users into memory # good-if you really need to load all users into memory
User.all.length
----

=== Where with Ranges [[where-ranges]] = = = Where with Range [[ Where-range ]

Use ranges instead of defining comparative conditions using a template for scalar values. 使用範圍而不是使用標量值的範本定義比較條件

[source,ruby] [來源，紅寶石]
----
# bad
User.where("created_at >= ?", 30.days.ago).where("created_at <= ?", 7.days.ago) Where (“ create _ at > = ?”，30. days.ago) . where (“ create _ at < = ?”，7. days.ago)
User.where("created_at >= ? AND created_at <= ?", 30.days.ago, 7.days.ago) Where (“ create _ at > = ? AND create _ at < = ?”，30. days.ago，7. days.ago)
User.where("created_at >= :start AND created_at <= :end", start: 30.days.ago, end: 7.days.ago) Where (“ create _ at > = : start AND create _ at < = : end”，start: 30. days.ago，end: 7. days.ago)

# good # 好
User.where(created_at: 30.days.ago..7.days.ago) Where (create _ at: 30. days.ago. . 7. days.ago)

# bad
User.where("created_at >= ?", 7.days.ago) Where (“ create _ at > = ?”，7. days.ago)

# good # 好
User.where(created_at: 7.days.ago..) Where (create _ at: 7. days.ago. .)

# note - ranges are inclusive or exclusive of their ending, not beginning # 音符範圍包括或排除其結束，而不是開始
User.where(created_at: 7.days.ago..) # produces >= Where (create _ at: 7. days.ago. .) # products > =
User.where(created_at: 7.days.ago...) # also produces >= Where (create _ at: 7. days.ago...) # 也生成 > =
User.where(created_at: ..7.days.ago) # inclusive: produces <= Where (create _ at: . . 7. days.ago) # include: products < =
User.where(created_at: ...7.days.ago) # exclusive: produces < Where (create _ at: ... 7. days.ago) # only: products <

# okish - there is no range syntax that would denote exclusion at the beginning of the range # okish-沒有範圍語法表示在範圍開始時排除
Customer.where("purchases_count > :min AND purchases_count <= :max", min: 0, max: 5) Customer.where (“ buy _ count > : min AND  御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御御
----

NOTE: Rails 6.0 or later is required for endless range Ruby 2.6 syntax, and Rails 6.0.3 for beginless range Ruby 2.7 syntax. 注意: Rails 6.0或更高版本對於無止境的 range Ruby 2.6語法是必需的，而 Rails 6.0.3對於無止境的 range Ruby 2.7語法是必需的

== Migrations = = 移民

=== Schema Version [[schema-version]] = = = 模式版本[[模式-版本]]

Keep the `schema.rb` (or `structure.sql`) under version control. 將‘ schema.rb’(或‘ structure.sql’)置於版本控制之下

=== DB Schema Load [[db-schema-load]] = = = DB 模式負載[[ DB-Schema-Load ]]

Use `rake db:schema:load` instead of `rake db:migrate` to initialize an empty database. 使用‘ rake db: schema: load’而不是‘ rake db: shift’初始化一個空資料庫

=== Default Migration Values [[default-migration-values]] = = = 默認遷移值[[ Default-mobile-Values ]]

Enforce default values in the migrations themselves instead of in the application layer. 在遷移本身而不是在應用程式層中強制執行預設值

[source,ruby] [來源，紅寶石]
----
# bad - application enforced default value # bad-應用程式強制預設值
class Product < ApplicationRecord 類別產品 < 應用紀錄
def amount 定額
self[:amount] || 0 自我[ : 金額] | | 0
end 結束
end 結束

# good - database enforced # 好的-資料庫強制執行
class AddDefaultAmountToProducts < ActiveRecord::Migration 類 AddDefaultAmountToProducts < ActiveRecord: : 遷移
def change 自然改變
change_column_default :products, :amount, 0 Change _ column _ default: products，: amount，0
end 結束
end 結束
----

While enforcing table defaults only in Rails is suggested by many Rails developers, it's an extremely brittle approach that leaves your data vulnerable to many application bugs. 雖然很多 Rails 開發人員建議只在 Rails 中執行表預設值，但這是一種非常脆弱的方法，使您的資料容易受到許多應用程式錯誤的影響
And you'll have to consider the fact that most non-trivial apps share a database with other applications, so imposing data integrity from the Rails app is impossible. 您還必須考慮到這樣一個事實，即大多數重要的應用程式與其他應用程式共享一個資料庫，因此從 Rails 應用程式實現資料完整性是不可能的

=== 3-state Boolean [[three-state-boolean]] = = = 3-state Boolean [[ three-state-Boolean ]]

With SQL databases, if a boolean column is not given a default value, it will have three possible values: `true`, `false` and `NULL`. 對於 SQL 資料庫，如果一個布林值列沒有給出預設值，那麼它將有三個可能的值: ‘ true’、‘ false’和‘ NULL’
Boolean operators https://en.wikipedia.org/wiki/Three-valued_logic[work in unexpected ways] with `NULL`. 布林值運算子的 https://en.wikipedia.org/wiki/three-valued_logic 為“ NULL”[以意想不到的方式工作]

For example in SQL queries, `true AND NULL` is `NULL` (not false), `true AND NULL OR false` is `NULL` (not false). This can make SQL queries return unexpected results. 例如，在 SQL 查詢中，‘ true AND NULL’是‘ NULL’(不是 false) ，‘ true AND NULL OR false’是‘ NULL’(不是 false)。這會使 SQL 查詢返回意外的結果

To avoid such situations, boolean columns should always have a default value and a `NOT NULL` constraint. 為了避免這種情況，布林值列應該始終有一個預設值和一個“ NOTNULL”約束

[source,ruby] [來源，紅寶石]
----
# bad - boolean without a default value # bad-boolean without a default value
add_column :users, :active, :boolean Add _ column: users，: active，: boolean

# good - boolean with a default value (`false` or `true`) and with restricted `NULL` # good-boolean 帶有預設值(‘ false’或‘ true’)和受限制的‘ NULL’
add_column :users, :active, :boolean, default: true, null: false Add _ column: users，: active，: boolean，default: true，null: false
add_column :users, :admin, :boolean, default: false, null: false Add _ column: users，: admin，: boolean，default: false，null: false
----

=== Foreign Key Constraints [[foreign-key-constraints]] = = = 外部索引鍵約束[[ Foreign-Key- ]]

Enforce foreign-key constraints. As of Rails 4.2, Active Record supports foreign key constraints natively. 實施外部索引鍵約束。從 Rails 4.2開始，活動記錄本身支援外部索引鍵約束

[source,ruby] [來源，紅寶石]
----
# bad - does not add foreign keys # bad-does not add foreign key
create_table :comment do |t| Create _ table: 註釋 do | t |
t.references :article 參考文獻: article
t.belongs_to :user 屬於: 使用者
t.integer :category_id T.int: Category _ id
end 結束

# good # 好
create_table :comment do |t| Create _ table: 註釋 do | t |
t.references :article, foreign_key: true 參考文獻: article，foreign _ key: true
t.belongs_to :user, foreign_key: true 屬於: user，foreign _ key: true
t.references :category, foreign_key: { to_table: :comment_categories } 參考文獻: type，foreign _ key: { to _ table: : comments _ Category }
end 結束
----

=== Change vs Up/Down [[change-vs-up-down]] = = = Change vs Up/Down [[ Change-vs-Up-Down ]]

When writing constructive migrations (adding tables or columns), use the `change` method instead of `up` and `down` methods. 在編寫構造性遷移(新增表或列)時，使用“ change”方法而不是“ up”和“ down”方法

[source,ruby] [來源，紅寶石]
----
# the old way
class AddNameToPeople < ActiveRecord::Migration 類 AddNameToPeople < ActiveRecord: : 遷移
def up 開始吧
add_column :people, :name, :string Add _ column: people，: name，: string
end 結束

def down 低調點
remove_column :people, :name 移除 _ column: people，: name
end 結束
end 結束

# the new preferred way # 新的首選方式
class AddNameToPeople < ActiveRecord::Migration 類 AddNameToPeople < ActiveRecord: : 遷移
def change 自然改變
add_column :people, :name, :string Add _ column: people，: name，: string
end 結束
end 結束
----

=== Define Model Class Migrations [[define-model-class-migrations]] = = = 定義模型類遷移[[輪廓定義-模型-類-遷移]]

If you have to use models in migrations, make sure you define them so that you don't end up with broken migrations in the future. 如果您必須在遷移中使用模型，請確保您定義了它們，以便將來不會出現遷移中斷的情況

[source,ruby] [來源，紅寶石]
----
# db/migrate/ 資料庫/遷移/.rb 。 rb
# frozen_string_literal: true 凍結字串: 真

# bad
class ModifyDefaultStatusForProducts < ActiveRecord::Migration 類修改 DefaultStatusForProducts < ActiveRecord: : 遷移
def change 自然改變
old_status = 'pending_manual_approval' Old _ status = “未決 _ 手動 _ 審批”
new_status = 'pending_approval' New _ status = ‘  待批准’

reversible do |dir| 可逆的
dir.up do
Product.where(status: old_status).update_all(status: new_status) Where (status: old _ status) . update _ all (status: new _ status)
change_column :products, :status, :string, default: new_status Change _ column: products，: status，: string，default: new _ status
end 結束

dir.down do Dir.Down
Product.where(status: new_status).update_all(status: old_status) Where (status: new _ status) . update _ all (status: old _ status)
change_column :products, :status, :string, default: old_status Change _ column: products，: status，: string，default: old _ status
end 結束
end 結束
end 結束
end 結束

# good # 好
# Define `table_name` in a custom named class to make sure that you run on the # 在自訂命名類中定義‘ table _ name’，以確保在
# same table you had during the creation of the migration. # 同樣的桌子，你在建立的遷移
# In future if you override the `Product` class and change the `table_name`, # 將來如果您重寫“ Product”類並更改“ table _ name”,
# it won't break the migration or cause serious data corruption. # 它不會破壞遷移或導致嚴重的資料損壞
class MigrationProduct < ActiveRecord::Base Class MigationProduct < ActiveRecord: : Base
self.table_name = :products Table _ name = : products
end 結束

class ModifyDefaultStatusForProducts < ActiveRecord::Migration 類修改 DefaultStatusForProducts < ActiveRecord: : 遷移
def change 自然改變
old_status = 'pending_manual_approval' Old _ status = “未決 _ 手動 _ 審批”
new_status = 'pending_approval' New _ status = ‘  待批准’

reversible do |dir| 可逆的
dir.up do
MigrationProduct.where(status: old_status).update_all(status: new_status) Where (status: old _ status) . update _ all (status: new _ status)
change_column :products, :status, :string, default: new_status Change _ column: products，: status，: string，default: new _ status
end 結束

dir.down do Dir.Down
MigrationProduct.where(status: new_status).update_all(status: old_status) Where (status: new _ status) . update _ all (status: old _ status)
change_column :products, :status, :string, default: old_status Change _ column: products，: status，: string，default: old _ status
end 結束
end 結束
end 結束
end 結束
----

=== Meaningful Foreign Key Naming [[meaningful-foreign-key-naming]] = = = 有意義的外部索引鍵命名[[有意義的外部索引鍵命名]]

Name your foreign keys explicitly instead of relying on Rails auto-generated FK names. (https://guides.rubyonrails.org/active_record_migrations.html#foreign-keys) 顯式地命名外部索引鍵，而不是依賴於 Rails 自動生成的 FK 名稱。( https://guides.rubyonrails.org/active_record_migrations.html#foreign-keys )

[source,ruby] [來源，紅寶石]
----
# bad
class AddFkArticlesToAuthors < ActiveRecord::Migration 類 AddFkArticlesToAuthors < ActiveRecord: : 遷移
def change 自然改變
add_foreign_key :articles, :authors Add _ foreign _ key: article，: author 新增 _ foreign _ key: 文章，: 作者
end 結束
end 結束

# good # 好
class AddFkArticlesToAuthors < ActiveRecord::Migration 類 AddFkArticlesToAuthors < ActiveRecord: : 遷移
def change 自然改變
add_foreign_key :articles, :authors, name: :articles_author_id_fk Add _ foreign _ key: article，: author，name: : article _ author _ id _ fk
end 結束
end 結束
----

=== Reversible Migration [[reversible-migration]] = = = 可逆遷移[[可逆遷移]]

Don't use non-reversible migration commands in the `change` method. 不要在“更改”方法中使用不可逆的遷移命令
Reversible migration commands are listed below. 下面列出了可逆轉的遷移命令
https://api.rubyonrails.org/classes/ActiveRecord/Migration/CommandRecorder.html[ActiveRecord::Migration::CommandRecorder]

[source,ruby] [來源，紅寶石]
----
# bad
class DropUsers < ActiveRecord::Migration Class DropUsers < ActiveRecord: : 遷移
def change 自然改變
drop_table :users Drop _ table: users
end 結束
end 結束

# good # 好
class DropUsers < ActiveRecord::Migration Class DropUsers < ActiveRecord: : 遷移
def up 開始吧
drop_table :users Drop _ table: users
end 結束

def down 低調點
create_table :users do |t| Create _ table: users do | t |
t.string :name Name
end 結束
end 結束
end 結束

# good # 好
# In this case, block will be used by create_table in rollback # 在這種情況下，block 將由 create _ table 在回滾中使用
# https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters.html#method-i-drop_table Https://api.rubyonrails.org/classes/activerecord/connectionadapters.html#method-i-drop_table
class DropUsers < ActiveRecord::Migration Class DropUsers < ActiveRecord: : 遷移
def change 自然改變
drop_table :users do |t| Drop _ table: users do | t |
t.string :name Name
end 結束
end 結束
end 結束
----

== Views = = 意見

=== No Direct Model View [[no-direct-model-view]] = = = No Direct Model View [[ No-Direct-Model-View ]]

Never call the model layer directly from a view. 永遠不要從檢視直接呼叫模型層

=== No Complex View Formatting [[no-complex-view-formatting]] = = = 無複雜檢視格式化[[無複雜檢視格式化]]

Avoid complex formatting in the views. 避免在檢視中使用複雜的格式
A view helper is useful for simple cases, but if it's more complex then consider using a decorator or presenter. 檢視幫助器對於簡單的情況很有用，但是如果它更複雜，那麼可以考慮使用裝飾器或演示器

=== Partials [[partials]] = = = 部分[[部分]]

Mitigate code duplication by using partial templates and layouts. 通過使用部分範本和佈局來減少程式碼重複

=== No Instance Variables in Partials [[no-instance-variables-in-partials]] = = = 分部中沒有實例變數[[沒有實例變數在分部中]]

Avoid using instance variables in partials, pass a local variable to `render` instead. 避免在局部變數中使用實例變數，而是傳遞一個局部變數來“呈現”
The partial may be used in a different controller or action, where the variable can have a different name or even be absent. 部分可以在不同的控製器或操作中使用，其中變數可以有不同的名稱，甚至不存在
In these cases, an undefined instance variable will not raise an exception whereas a local variable will. 在這些情況下，未定義的實例變數不會引發異常，而局部變數會引發異常

[source,erb] [源，erb ]
----


<%= render 'course_description' %> <% = 呈現“ course _ description”% >

<%= @course.description %> <% =@course. description% >



<%= render 'course_description', course: @course %> 渲染“ course _ description”，course:@course% >

<%= course.description %> <% = course. description% >
----

== Internationalization = = 國際化

=== Locale Texts [[locale-texts]] = = = 語言環境文字[[語言環境-文字]]

No strings or other locale specific settings should be used in the views, models and controllers. 檢視、模型和控製器中不應使用字串或其他特定於區域設定
These texts should be moved to the locale files in the `config/locales` directory. 這些文字應該移動到‘ config/locales’目錄中的 locale 檔案中

=== Translated Labels [[translated-labels]] = = = 翻譯標籤[[翻譯標籤]]

When the labels of an Active Record model need to be translated, use the `activerecord` scope: 當需要翻譯活動記錄模型的標籤時，使用“ activerrecord”範疇:

----
en: 嗯:
activerecord: 活動唱片:
models: 模型:
user: Member 使用者: 成員
attributes: 屬性:
user: 使用者:
name: 'Full name' 姓名: 「全名」
----

Then `User.model_name.human` will return "Member" and `User.human_attribute_name("name")` will return "Full name". 然後，‘ User.model _ name. human’將返回“ Member”，而‘ User.human _ tribute _ name (“ name”)’將返回“ Full name”
These translations of the attributes will be used as labels in the views. 這些屬性的轉換將用作檢視中的標籤

=== Organize Locale Files [[organize-locale-files]] = = = 組織語言環境檔案[[組織-語言環境檔案]]

Separate the texts used in the views from translations of Active Record attributes. 將檢視中使用的文字與 ActiveRecord 屬性的翻譯分開
Place the locale files for the models in a folder `locales/models` and the texts used in the views in folder `locales/views`. 將模型的區域設定檔案放在“ locales/model”資料夾中，將檢視中使用的文字放在“ locales/views”資料夾中

When organization of the locale files is done with additional directories, these directories must be described in the `application.rb` file in order to be loaded. 當使用其他目錄來組織區域設定檔案時，必須在‘ application.rb’檔案中描述這些目錄，以便載入它們

[source,ruby] [來源，紅寶石]
----
# config/application.rb
config.i18n.load_path += Dir[Rails.root.join('config', 'locales', '**', '*.{rb,yml}')] Load _ path + = Dir [ Rails.root.join (‘ config’，‘ locales’,’* *’,’* . { rb，yml }’)]
----

=== Shared Localization [[shared-localization]] = = = 共享本地化[[共享-本地化]]

Place the shared localization options, such as date or currency formats, in files under the root of the `locales` directory. 將共享本地化選項(如日期或貨幣格式)放在“ locales”目錄根目錄下的檔案中

=== Short I18n [[short-i18n]] = = = Short I18n [[ Short-I18n ]]

Use the short form of the I18n methods: `I18n.t` instead of `I18n.translate` and `I18n.l` instead of `I18n.localize`. 使用 I18n 方法的縮寫形式: ‘ I18n.t’代替‘ I18n.trans’和‘ I18n.l’代替‘ I18n.localize’

=== Lazy Lookup [[lazy-lookup]] = = = 惰性尋找[[惰性尋找]]

Use "lazy" lookup for locale entries from views and controllers. Let's say we have the following structure: 使用“延遲”尋找來自檢視和控製器的語言環境條目:

----
en: 嗯:
users: 使用者:
show: 展示:
title: 'User details page' 標題: 「使用者資料頁」
----

The value for `users.show.title` can be looked up in the template `app/views/users/show.html.haml` like this: 可以在範本‘ app/views/users/show.html. haml’中尋找‘ users.show.title’的值，如下所示:

[source,ruby] [來源，紅寶石]
----
# bad
= t 'users.show.title' = t‘ users.show.title’

# good # 好
= t '.title' = t’. title’
----

=== Dot-separated Keys [[dot-separated-keys]] = = = 點分隔鍵[[點分隔鍵]]

Use dot-separated locale keys instead of specifying the `:scope` option with an array or a single symbol. 使用點分隔的區域設定鍵，而不是使用陣列或單個符號指定“ : scope”選項
Dot-separated notation is easier to read and trace the hierarchy. 點分隔符號更容易閱讀和跟蹤層次結構

[source,ruby] [來源，紅寶石]
----
# bad
I18n.t :record_invalid, scope: [:activerecord, :errors, :messages] T: record _ void，scope: [ : activerecord，: error，: message ]

# good # 好
I18n.t :record_invalid, scope: 'activerecord.errors.messages' T: record _ void，範疇: ‘ activerecord.errors.message’
I18n.t 'activerecord.errors.messages.record_invalid' I18n.t‘ activerecord.errors.messages.record _ void’‘ activerecord.errors.messages.record _ void’

# bad
I18n.t :title, scope: :invitation 標題，範圍: 邀請

# good # 好
I18n.t 'title.invitation' 頭銜邀請函
----

=== I18n Guides [[i18n-guides]] = = = I18n 指南[[ I18n 指南]]

More detailed information about the Rails I18n can be found in the https://guides.rubyonrails.org/i18n.html[Rails Guides] 有關 Rails i 18n 的詳細資料，可參閱 https://Guides.rubyonrails.org/I18n.html [ Rails Guides ]


== Assets = = 資產

Use the https://guides.rubyonrails.org/asset_pipeline.html[asset pipeline] to leverage organization within your application. 使用 https://guides.rubyonrails.org/asset_pipeline.html [資產管道]來利用應用程式中的組織

=== Reserve `app/assets` [[reserve-app-assets]] = = = Reserve‘ app/asset’[[ Reserve-app-asset ]]

Reserve `app/assets` for custom stylesheets, javascripts, or images. 為自訂樣式表、 javascript 或圖像保留“應用程式/資產”

=== `lib/assets` [[lib-assets]] = = = ‘ lib/asset’[[ lib-asset ]]

Use `lib/assets` for your own libraries that don't really fit into the scope of the application. 對自己的庫使用“ lib/asset”，這些庫並不真正適合應用程式的範圍

=== `vendor/assets` [[vendor-assets]] = = = ‘賣主/資產’[[賣主-資產]]

Third party code such as https://jquery.com/[jQuery] or https://twitter.github.com/bootstrap/[bootstrap] should be placed in `vendor/assets`. 第三方程式碼，如 https://jQuery.com/(jQuery)或 https://twitter.github.com/bootstrap/(bootstrap) ，應該放在“供應商/資產”中

=== `gem/assets` [[gem-assets]] = = = ‘ gem/asset’[[ gem-asset ]]

When possible, use gemified versions of assets (e.g. https://github.com/rails/jquery-rails[jquery-rails], https://github.com/joliss/jquery-ui-rails[jquery-ui-rails], https://github.com/thomas-mcdonald/bootstrap-sass[bootstrap-sass], https://github.com/zurb/foundation[zurb-foundation]). 在可能的情況下，使用雙 https://github.com/rails/jquery-rails 版本的資產(例如: https://github.com/joliss/jquery-ui-rails [ jquery-ails ]、 https://github.com/thomas-mcdonald/bootstrap-sass [ bootstrap-sass ]、 https://github.com/zurb/foundation [ zurb- foundation ])

== Mailers = = 郵遞員

=== Mailer Name [[mailer-name]] = = = 郵遞員姓名[[郵遞員姓名]]

Name the mailers `SomethingMailer`. 把郵遞員的名字命名為“ Something Mailer”
Without the Mailer suffix it isn't immediately apparent what's a mailer and which views are related to the mailer. 如果沒有 Mailer 後綴，就不能立即看出什麼是 Mailer，以及哪些檢視與 Mailer 相關

=== HTML Plain Email [[html-plain-email]] = = = HTML 普通電子郵件[ HTML-Plain- 電子郵件]

Provide both HTML and plain-text view templates. 提供 HTML 和純文字檢視範本

=== Enable Delivery Errors [[enable-delivery-errors]] = = = 啟用傳遞錯誤[[啟用-傳遞-錯誤]]

Enable errors raised on failed mail delivery in your development environment. 啟用在開發環境中郵件傳遞失敗時引發的錯誤
The errors are disabled by default. 默認情況下停用這些錯誤

[source,ruby] [來源，紅寶石]
----
# config/environments/development.rb # config/environment/development.rb

config.action_mailer.raise_delivery_errors = true Action _ mailer
----

=== Local SMTP [[local-smtp]] = = = 本地 SMTP [[ Local-SMTP ]]

Use a local SMTP server like https://github.com/sj26/mailcatcher[Mailcatcher] in development environment. 在開發環境中使用本地 SMTP 伺服器，如 https://github.com/sj26/Mailcatcher [郵件捕捉器]

[source,ruby] [來源，紅寶石]
----
# config/environments/development.rb # config/environment/development.rb

config.action_mailer.smtp_settings = { Action _ mailer. smtp _ sets = {
address: 'localhost', 地址: ‘ localhost’,
port: 1025, 連接埠號: 1025,
# more settings # 更多設定
}
----

=== Default Hostname [[default-hostname]] = = = 默認主機名[[ Default-Hostname ]]

Provide default settings for the host name. 提供主機名的默認設定

[source,ruby] [來源，紅寶石]
----
# config/environments/development.rb # config/environment/development.rb
config.action_mailer.default_url_options = { host: "#{local_ip}:3000" } Action _ mailer. default _ url _ options = { host: “ # { local _ ip } : 3000”}

# config/environments/production.rb # config/environment/production.rb
config.action_mailer.default_url_options = { host: 'your_site.com' } Config.action _ mailer. default _ url _ options = { host: ‘ your _ site.com’}

# in your mailer class # 在你的郵件課上
default_url_options[:host] = 'your_site.com' Default _ url _ options [ : host ] = “ your _ site.com”
----

=== Email Addresses [[email-addresses]] = = = 電子郵件地址[[電子郵件地址]]

Format the from and to addresses properly. 正確設定發件人和發件人地址的格式
Use the following format: 使用以下格式:

[source,ruby] [來源，紅寶石]
----
# in your mailer class # 在你的郵件課上
default from: 'Your Name 默認來自: ‘ Your Name'
----

If you're using Rails 6.1 or higher, you can use the `email_address_with_name` method: 如果你使用 Rails 6.1或更高版本，你可以使用‘ email _ address _ with _ name’方法:

[source,ruby] [來源，紅寶石]
----
# in your mailer class # 在你的郵件課上
default from: email_address_with_name('info@your_site.com', 'Your Name') 默認來自: email _ address _ with _ Name (‘ info@Your _ site.com’，‘ Your Name’)
----

=== Delivery Method Test [[delivery-method-test]] = = = 交付方法測試[[交付方法測試]]

Make sure that the e-mail delivery method for your test environment is set to `test`: 確保測試環境的電子郵件傳遞方法設定為“ test”:

[source,ruby] [來源，紅寶石]
----
# config/environments/test.rb # config/environment/test.rb

config.action_mailer.delivery_method = :test Action _ mailer. distribution _ method = : test
----

=== Delivery Method SMTP [[delivery-method-smtp]] = = = 傳遞方法 SMTP [[傳遞方法 -SMTP ]]

The delivery method for development and production should be `smtp`: 開發和生產的交付方式應該是“ smtp”:

[source,ruby] [來源，紅寶石]
----
# config/environments/development.rb, config/environments/production.rb 組態/環境/發展.rb，組態/環境/產品.rb

config.action_mailer.delivery_method = :smtp Action _ mailer. distribution _ method = : smtp
----

=== Inline Email Styles [[inline-email-styles]] = = = 內聯電子郵件樣式[[內聯-電子郵件樣式]]

When sending html emails all styles should be inline, as some mail clients have problems with external styles. 當傳送 html 電子郵件時，所有的樣式都應該是內聯的，因為一些郵件客戶端有外部樣式的問題
This however makes them harder to maintain and leads to code duplication. 然而，這使得它們更難維護，並導致程式碼複製
There are two similar gems that transform the styles and put them in the corresponding html tags: https://github.com/fphilipe/premailer-rails[premailer-rails] and https://github.com/Mange/roadie[roadie]. 有兩個類似的 gems 可以轉換樣式並將它們放入相應的 html 標記中: https://github.com/fphilipe/premailer-rails (premailer-ails)和 https://github.com/mange/roadie (roadie)

=== Background Email [[background-email]] = = = 背景郵件[[背景-電子郵件]]

Sending emails while generating page response should be avoided. 應該避免在生成頁面響應時傳送電子郵件
It causes delays in loading of the page and request can timeout if multiple email are sent. 它導致頁面載入的延遲，如果傳送多封電子郵件，請求可能會超時
To overcome this emails can be sent in background process with the help of https://github.com/mperham/sidekiq[sidekiq] gem. 為了克服這個問題，可以在後台傳送電子郵件的過程中，借助 https://github.com/mperham/sidekiq [ sidekiq ] gem

== Active Support Core Extensions = = 主動支援核心擴展

=== `try!` [[try-bang]] = = = ‘ try!’[ try-bang ]

Prefer Ruby 2.3's safe navigation operator `&.` over `ActiveSupport#try!`. 更喜歡 Ruby 2.3的安全導航運算子“ &”而不是“ ActiveSupport # try!”

[source,ruby] [來源，紅寶石]
----
# bad
obj.try! :fly - 目標-飛

# good # 好
obj&.fly 飛
----

=== Active Support Aliases [[active_support_aliases]] = = = 活動支援別名[[ Active _ Support _ Aliases ]]

Prefer Ruby's Standard Library methods over `ActiveSupport` aliases. 比起“ ActiveSupport”別名，更喜歡 Ruby 的標準庫方法

[source,ruby] [來源，紅寶石]
----
# bad
'the day'.starts_with? 'th' ‘ the day’以‘ th’開頭
'the day'.ends_with? 'ay' “ the day”以“ ay”結尾

# good # 好
'the day'.start_with? 'th' ‘ the day’
'the day'.end_with? 'ay' ‘ the day’. end _ with? ‘ ay’
----

=== Active Support Extensions [[active_support_extensions]] = = = 活動支援擴展[[ Active _ Support _ tended ]]

Prefer Ruby's Standard Library over uncommon Active Support extensions. 喜歡 Ruby 的標準庫勝過不常見的活動支援擴展

[source,ruby] [來源，紅寶石]
----
# bad
(1..50).to_a.forty_two (1. . 50) . 到 _ a. 42
1.in? [1, 2] 1英吋? [1,2]
'day'.in? 'the day' “一天”。在? “一天”

# good # 好
(1..50).to_a[41] (1. . 50) . to _ a [41]
[1, 2].include? 1 [1,2]包括
'the day'.include? 'day' ‘ the day’包括? ‘ day’
----

=== `inquiry` [[inquiry]] = = = “詢問”[[詢問]]

Prefer Ruby's comparison operators over Active Support's `Array#inquiry`, and `String#inquiry`. 比起 Active Support 的“ Array # query”和“ String # query”，更喜歡 Ruby 的比較運算子

[source,ruby] [來源，紅寶石]
----
# bad - String#inquiry # bad-String # 質詢
ruby = 'two'.inquiry Ruby = ‘ two’詢問
ruby.two? Ruby 兩個？

# good # 好
ruby = 'two' Ruby = “2”
ruby == 'two' 紅寶石 = = 兩個

# bad - Array#inquiry 陣列查詢
pets = %w(cat dog).inquiry 寵物 =% w (貓狗)。查詢
pets.gopher? 寵物，地鼠？

# good # 好
pets = %w(cat dog) 寵物 =% w (貓狗)
pets.include? 'cat' 寵物，包括? “貓”
----

=== `exclude?` [[exclude]] = = “排除?”[[排除]]

Prefer Active Support's `exclude?` over Ruby's negated `include?`. 更喜歡主動支援的“排除?”而不是 Ruby 的“否定包含?”

[source,ruby] [來源，紅寶石]
----
# bad
!array.include?(2) 包括? (2)
!hash.include?(:key) ! hash.include? (: key)
!string.include?('substring') Include? (‘ substring’)

# good # 好
array.exclude?(2) 排除? (2)
hash.exclude?(:key) 不包括? (: key)
string.exclude?('substring') 排除? (‘ substring’)
----

=== Prefer using squiggly heredoc over `strip_heredoc` [[prefer-squiggly-heredoc]] = = = 更喜歡使用彎曲的 herdoc 而不是‘ Strip _ herdoc’[[更喜歡-彎曲的-herdoc ]]

If you're using Ruby 2.3 or higher, prefer squiggly heredoc (`<<~`) over Active Support's `strip_heredoc`. 如果您正在使用 Ruby 2.3或更高版本，請選擇彎曲的 herdoc (‘ < < ~’) ，而不是 Active Support 的‘ Strip _ herdoc’

[source,ruby] [來源，紅寶石]
----
# bad
< some text 一些簡訊
EOS

# bad
<<-EOS.strip_heredoc < <-EOS.Strip _ herdoc
some text 一些簡訊
EOS

# good # 好
<<~EOS < < ~ EOS
some text 一些簡訊
EOS
----

=== Prefer `to_fs` for Formatted Strings [[prefer-to-fs]] = = = 對於格式化字串更喜歡‘ to _ fs’[[傾向於-to-fs ]]

If you're using Rails 7.0 or higher, prefer `to_fs` over `to_formatted_s`. `to_formatted_s` is just too cumbersome for a method used that frequently. 如果您正在使用 Rails 7.0或更高版本，請選擇“ to _ fs‘ over‘ to _ format _ s’”。“ to _ format _ s”對於頻繁使用的方法來說太麻煩了

[source,ruby] [來源，紅寶石]
----
# bad
time.to_formatted_s(:db) To _ format _ s (: db)
date.to_formatted_s(:db) To _ format _ s (: db)
datetime.to_formatted_s(:db) To _ format _ s (: db)
42.to_formatted_s(:human) 42.to _ format _ s (: human)

# good # 好
time.to_fs(:db) Time.to _ fs (: db)
date.to_fs(:db) To _ fs (: db)
datetime.to_fs(:db) To _ fs (: db)
42.to_fs(:human) 42.to _ fs (: human)
----

== Time = = 時間

=== Time Zone Config [[tz-config]] = = = 時區組態[[ tz-Config ]]

Configure your timezone accordingly in `application.rb`. 在‘ application.rb’中相應地組態您的時區

[source,ruby] [來源，紅寶石]
----
config.time_zone = 'Eastern European Time' Time _ zone = ‘ Eastern European Time’
# optional - note it can be only :utc or :local (default is :utc) # 可選-注意，它可以只是: utc 或: local (預設值是: utc)
config.active_record.default_timezone = :local Active _ record. default _ timezone = : local
----

=== `Time.parse` [[time-parse]] = = ‘ Time.parse’[[ time-parse ]]

Don't use `Time.parse`. 不要使用‘ Time. parse’

[source,ruby] [來源，紅寶石]
----
# bad
Time.parse('2015-03-02 19:05:37') # => Will assume time string given is in the system's time zone. Parse (’2015-03-0219:05:37’) # = > 將假設給定的時間字串在系統的時區中

# good # 好
Time.zone.parse('2015-03-02 19:05:37') # => Mon, 02 Mar 2015 19:05:37 EET +02:00 Time.zone.parse (’2015-03-0219:05:37’) # = > Mon，02 Mar 201519:05:37 EET + 02:00
----

=== `to_time` [[to-time]] = = = ‘ to _ time’[[ to-time ]]

Don't use https://api.rubyonrails.org/classes/String.html#method-i-to_time[`String#to_time`] 不要使用 https://api.rubyonrails.org/classes/String.html#method-i-to_time [‘ String # to _ time’]

[source,ruby] [來源，紅寶石]
----
# bad - assumes time string given is in the system's time zone. # bad ——假設給定的時間串在系統的時區內
'2015-03-02 19:05:37'.to_time “2015-03-0219:05:37”到 _ time

# good # 好
Time.zone.parse('2015-03-02 19:05:37') # => Mon, 02 Mar 2015 19:05:37 EET +02:00 Time.zone.parse (’2015-03-0219:05:37’) # = > Mon，02 Mar 201519:05:37 EET + 02:00
----

=== `Time.now` [[time-now]] = = ‘ Time. now’[ Time-now ]

Don't use `Time.now`. 別用時間，現在

[source,ruby] [來源，紅寶石]
----
# bad
Time.now # => Returns system time and ignores your configured time zone. Now # = > 返回系統時間並忽略組態的時區

# good # 好
Time.zone.now # => Fri, 12 Mar 2014 22:04:47 EET +02:00 Time.zone.now # = > Fri，12 Mar 201422:04:47 EET + 02:00
Time.current # Same thing but shorter. 時間，當前時間，一樣，但是更短
----

=== Prefer `all_(day|week|month|quarter|year)` over range of date/time [[date-time-range]] = = = 在日期/時間範圍[[日期-時間-範圍]]之上更喜歡‘ all _ (day | week | month | Quarter | year)’

Prefer `all_(day|week|month|quarter|year)` over `beginning_of_(day|week|month|quarter|year)..end_of_(day|week|month|quarter|year)` 喜歡‘ all _ (day | week | month | Quarter | year)’而不喜歡‘ start _ of _ (day | week | month | Quarter | year) . end _ of _ (day | week | month | Quarter | year)’
to get the range of date/time. 得到日期/時間的範圍

[source,ruby] [來源，紅寶石]
----
# bad
date.beginning_of_day..date.end_of_day 開始 _ of _ day. . date.end _ of _ day
date.beginning_of_week..date.end_of_week _ week _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
date.beginning_of_month..date.end_of_month Date _ of _ month. . date. end _ of _ month
date.beginning_of_quarter..date.end_of_quarter 開始 _ 季度. . 日期. 結束 _ 季度
date.beginning_of_year..date.end_of_year Date _ of _ year. . date. end _ of _ year

# good # 好
date.all_day 一整天
date.all_week 整個星期
date.all_month 所有 _ 月
date.all_quarter 四分之一
date.all_year 全年
----

== Duration = = 持續時間

=== Duration Application = = = 申請期限

If used without a parameter, prefer `from_now` and `ago` instead of `since`, `after`, `until` or `before`. 如果不帶參數使用，請選擇“ from _ now”和“ ago”，而不是“ since”、“ after”、“ until”或“ before”

[source,ruby] [來源，紅寶石]
----
# bad - It's not clear that the qualifier refers to the current time (which is the default parameter) # bad-不清楚限定符是否指當前時間(默認參數)
5.hours.since 5小時前
5.hours.after 5小時後
5.hours.before 5小時前
5.hours.until 5個小時，直到

# good # 好
5.hours.from_now 從現在開始5個小時
5.hours.ago 5小時前
----

If used with a parameter, prefer `since`, `after`, `until` or `before` instead of `from_now` and `ago`. 如果與參數一起使用，請選擇“ since”、“ after”、“ until”或“ before”，而不是“ from _ now”和“ ago”

[source,ruby] [來源，紅寶石]
----
# bad - It's confusing and misleading to read # bad-讀起來令人困惑和誤導
2.days.from_now(yesterday) From _ now (昨天)
2.days.ago(yesterday) 2天前(昨天)

# good # 好
2.days.since(yesterday) 從(昨天)起2天
2.days.after(yesterday) (昨日)後2天
2.days.before(yesterday) 前天(昨天)
2.days.until(yesterday) 2天。直到(昨天)
----

Avoid using negative numbers for the duration subject. Always prefer using a qualifier that allows using positive literal numbers. 避免在持續時間主題中使用負數。總是喜歡使用允許使用正數的限定符

[source,ruby] [來源，紅寶石]
----
# bad - It's confusing and misleading to read # bad-讀起來令人困惑和誤導
-5.hours.from_now -5個小時，從現在開始
-5.hours.ago -5小時前

# good # 好
5.hours.ago 5小時前
5.hours.from_now 從現在開始5個小時
----

=== Duration Arithmetic = = 持續時間演演演演演演演演算法

Use Duration methods instead of adding and subtracting with the current time. 使用持續時間方法，而不是使用當前時間進行加減

[source,ruby] [來源，紅寶石]
----
# bad
Time.current - 1.minute 時間，當前時間，一分鐘
Time.zone.now + 2.days 時區，現在 + 2天

# good # 好
1.minute.ago 一分鐘前
2.days.from_now 從現在開始
----

== Bundler = = Bundler

=== Dev/Test Gems [[dev-test-gems]] = = = Dev/Test Gems [[ Dev-Test-Gems ]]

Put gems used only for development or testing in the appropriate group in the Gemfile. 將只用於開發或測試的 gem 放在 Gemfile 的適當組中

=== Only Good Gems [[only-good-gems]] = = = Only Good Gems [[ Only-Good-Gems ]]

Use only established gems in your projects. 僅在項目中使用已建立的 gem
If you're contemplating on including some little-known gem you should do a careful review of its source code first. 如果您正在考慮包含一些鮮為人知的 gem，那麼您應該首先仔細檢查它的原始碼

=== `Gemfile.lock` [[gemfile-lock]] = = = ‘ Gemfile.lock’[[ gemfile-lock ]]

Do not remove the `Gemfile.lock` from version control. 不要從版本控制中移除“ Gemfile.lock”
This is not some randomly generated file - it makes sure that all of your team members get the same gem versions when they do a `bundle install`. 這不是一些隨機生成的檔案-它確保您的團隊成員在執行“捆綁安裝”時獲得相同的 gem 版本

== Testing = = 測試

=== Integration Testing = = = 整合測試

Prefer integration style controller tests over functional style controller tests, https://api.rubyonrails.org/v7.0.0/classes/ActionController/TestCase.html[as recommended in the Rails documentation]. 更喜歡整合風格的控製器測試，而不是功能風格的控製器測試， https://api.rubyonrails.org/v7.0.0/classes/actioncontroller/testcase.html [就像 Rails 檔案中推薦的那樣]

[source,ruby] [來源，紅寶石]
----
# bad
class MyControllerTest < ActionController::TestCase 類 MyControllerTest < ActionController: : TestCase
end 結束

# good # 好
class MyControllerTest < ActionDispatch::IntegrationTest 類 MyControllerTest < ActionDispatch: : IntegrationTest
end 結束
----

=== `freeze_time` [[freeze-time]] = = “凍結時間”[[凍結時間]]

Prefer https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-freeze_time[ActiveSupport::Testing::TimeHelpers#freeze_time] over https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-travel_to[ActiveSupport::Testing::TimeHelpers#travel_to] with an argument of the current time. 使用 https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-freeze_time [ ActiveSupport: : Testing: : TimeHelpers # free_ time ]優先於使用當前時間參數的 https://api.rubyonrails.org/classes/ActiveSupport/Testing/TimeHelpers.html#method-i-travel_to [ ActiveSupport: : Testing: : TimeHelpers # travel _ to ]

[source,ruby] [來源，紅寶石]
----
# bad
travel_to(Time.now) Travel _ to (Time.now)
travel_to(DateTime.now) Travel _ to (DateTime.now)
travel_to(Time.current) Travel _ to (Time.current)
travel_to(Time.zone.now) Travel _ to (Time.zone.now)
travel_to(Time.now.in_time_zone) Travel _ to (Time.now. in _ time _ zone)
travel_to(Time.current.to_time) Travel _ to (Time.current.to _ time)

# good # 好
freeze_time 凍結時間
----

== Managing Processes = = 流程管理

=== Foreman [[foreman]] = = = 工頭[[工頭]]

If your projects depends on various external processes use https://github.com/ddollar/foreman[foreman] to manage them. 如果你的項目依賴於各種外部流程，那麼就使用 https://github.com/ddollar/foreman 來管理它們

== Further Reading = = 延伸閱讀

There are a few excellent resources on Rails style, that you should consider if you have time to spare: 有一些關於 Rails 風格的優秀資源，如果你有時間的話，你應該考慮一下:

* https://www.informit.com/store/rails-5-way-9780134657677[The Rails 5 Way] * https://www.informit.com/store/Rails-5-Way-9780134657677
* https://guides.rubyonrails.org/[Ruby on Rails Guides] * https://Guides.rubyonrails.org/[ Ruby on Rails Guide ]
* https://pragprog.com/book/rspec3/effective-testing-with-rspec-3[Effective Testing with RSpec 3] * https://pragprog.com/book/rspec3/Effective-Testing-with-RSpec-3[使用 RSpec 3進行有效測試]
* https://pragprog.com/book/hwcuc/the-cucumber-book[The Cucumber Book] * https://pragprog.com/Book/hwcuc/The-Cucumber-Book [黃瓜書]
* https://leanpub.com/everydayrailsrspec[Everyday Rails Testing with RSpec] * https://leanpub.com/everydayrailsrspec 〔使用 RSpec 進行日常軌道測試〕
* https://pragprog.com/book/nrtest3/rails-5-test-prescriptions[Rails 5 Test Prescriptions] * https://pragprog.com/book/nrtest3/Rails-5-Test-Prescriptions 〔鐵路五項測試處方〕
* https://rspec.rubystyle.guide[RSpec Style Guide] * https://RSpec.rubystyle.Guide [規格說明書]

== Contributing = = 貢獻

Nothing written in this guide is set in stone. 這本指南里沒有什麼是一成不變的
It's my desire to work together with everyone interested in Rails coding style, so that we could ultimately create a resource that will be beneficial to the entire Ruby community. 我希望與每個對 Rails 編碼風格感興趣的人一起工作，這樣我們最終可以建立一個對整個 Ruby 社區都有益的資源

Feel free to open tickets or send pull requests with improvements. 隨時打開門票或傳送與改進拉請求
Thanks in advance for your help! 先謝謝你的幫助

You can also support the project (and RuboCop) with financial contributions via https://www.patreon.com/bbatsov[Patreon]. 你也可以通過 https://www.Patreon.com/bbatsov 來支援這個項目(和 RuboCop)

=== How to Contribute? = = = 如何貢獻？

It's easy, just follow the contribution guidelines below: 這很簡單，只要遵循下面的貢獻準則:

* https://help.github.com/articles/fork-a-repo[Fork] the https://github.com/rubocop/rails-style-guide[project] on GitHub * 在 gitHub 上 https://help.GitHub.com/articles/Fork-a-repo https://GitHub.com/rubocop/rails-style-guide [項目]
* Make your feature addition or bug fix in a feature branch. * 在特性分支中新增特性或修復錯誤
* Include a http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html[good description] of your changes * 列出修改的 http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html [詳細說明]
* Push your feature branch to GitHub 把你的功能分支推到 GitHub
* Send a https://help.github.com/articles/using-pull-requests[Pull Request] * 傳送 https://help.github.com/articles/using-Pull-requests

== License = = 許可證

image:https://i.creativecommons.org/l/by/3.0/88x31.png[Creative Commons License] 圖片來源: https://i.creativecommons.org/l/by/3.0/88x31.png [知識共享許可協議]
This work is licensed under a https://creativecommons.org/licenses/by/3.0/deed.en_US[Creative Commons Attribution 3.0 Unported License] 這項工作是根據一個 https://creativecommons.org/licenses/by/3.0/deed.en_us [知識共享署名3.0未移植許可證]

== Spread the Word = = 散播謠言

A community-driven style guide is of little use to a community that doesn't know about its existence. 社區驅動的樣式指南對於不知道其存在的社區沒有多大用處
Tweet about the guide, share it with your friends and colleagues. 把指南發到推特上，與你的朋友和同事分享
Every comment, suggestion or opinion we get makes the guide just a little bit better. 我們得到的每一個評論、建議或意見都會使指南更好一點
And we want to have the best possible guide, don't we? 我們需要最好的向導，不是嗎？

Cheers, + 乾杯，+
https://twitter.com/bbatsov[Bozhidar]


